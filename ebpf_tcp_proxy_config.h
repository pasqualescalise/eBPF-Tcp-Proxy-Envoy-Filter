#include "ebpf_tcp_proxy.h"

#include "envoy/registry/registry.h"
#include "envoy/server/filter_config.h"

#include "source/extensions/filters/network/tcp_proxy/config.h"

#include "envoy/extensions/filters/network/tcp_proxy/v3/ebpf_tcp_proxy.pb.h"
#include "envoy/extensions/filters/network/tcp_proxy/v3/ebpf_tcp_proxy.pb.validate.h"

#include "ebpf_tcp_proxy.skel.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace TcpProxy {
namespace EbpfTcpProxy {

/**
 * Use the skeleton generated by bpftool to load eBPF programs
 */
class EbpfLoader {
public:
  static bool loadeBPFPrograms(int interface_index,
                               int* connection_fingerprint_to_connection_fingerprint_map_fd);

  static bool unloadeBPFPrograms(int interface_index);

private:
  // program indexes
  enum {
    PROG_XDP_PARSE_HEADERS = 0,
    PROG_XDP_REDIRECT_PACKET,
    PROG_CLS_BLOCK_FINS,

    MAX_NUM_OF_PROGRAMS
  };

  struct ProgramDescription {
    char name[256];
    enum bpf_prog_type type;
    int map_prog_idx;
    struct bpf_program* prog;
  };

  // description of all the programs
  static constexpr const ProgramDescription progs[] = {
      {"xdp/parse_headers", BPF_PROG_TYPE_XDP, PROG_XDP_PARSE_HEADERS, NULL},
      {"xdp/redirect_packet", BPF_PROG_TYPE_XDP, PROG_XDP_REDIRECT_PACKET, NULL},
      {"cls/block_fins", BPF_PROG_TYPE_SCHED_CLS, PROG_CLS_BLOCK_FINS, NULL},
  };

  static bool attachXDP(struct bpf_object_skeleton* skel, int programs_map_fd, int interface_index);
  static bool attachTC(struct bpf_object_skeleton* skel, int interface_index);

  static bool detachXDP(int interface_index);
  static bool detachTC();
};

/**
 * Config registration for the EbpfTcpProxy filter
 */
class EbpfTcpProxyConfigFactory
    : public Common::FactoryBase<envoy::extensions::filters::network::tcp_proxy::v3::EbpfTcpProxy> {
public:
  EbpfTcpProxyConfigFactory() : FactoryBase("ebpf_tcp_proxy", true){};

  ~EbpfTcpProxyConfigFactory() { EbpfLoader::unloadeBPFPrograms(interface_index); }

  std::string name() const override { return "ebpf_tcp_proxy"; }

  std::set<std::string> configTypes() override {
    return {"envoy.extensions.filters.network.tcp_proxy.v3.EbpfTcpProxy"};
  }

private:
  int interface_index;
  int connection_fingerprint_to_connection_fingerprint_map_fd;

  Network::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy& proto_config,
      Server::Configuration::FactoryContext& context);

  Network::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoy::extensions::filters::network::tcp_proxy::v3::EbpfTcpProxy& proto_config,
      Server::Configuration::FactoryContext& context);
};

/**
 * Static registration for the EbpfTcpProxy filter
 */
REGISTER_FACTORY(EbpfTcpProxyConfigFactory, Server::Configuration::NamedNetworkFilterConfigFactory);

} // namespace EbpfTcpProxy
} // namespace TcpProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
