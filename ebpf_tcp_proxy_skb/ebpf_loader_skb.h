#include "ebpf_tcp_proxy_skb/ebpf/ebpf_tcp_proxy_skb.skel.h"
#include "ebpf_tcp_proxy_skb.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace TcpProxy {
namespace EbpfTcpProxy {
namespace EbpfTcpProxySKB {

/**
 * Use the skeleton generated by bpftool to load eBPF programs
 */
class EbpfLoader {
public:
  static void loadeBPFPrograms(int* sockhash_fd,
                               int* connection_fingerprint_to_connection_fingerprint_map_fd);

  static void unloadeBPFPrograms();

private:
  // program indexes
  enum {
    PROG_SOCKOPS_ADD_TO_SOCKHASH = 0,
    PROG_SK_SKB_VERDICT_REDIRECT_SOCKET,

    MAX_NUM_OF_PROGRAMS
  };

  struct ProgramDescription {
    char name[256];
    enum bpf_prog_type type;
    int map_prog_idx;
    struct bpf_program* prog;
  };

  // description of all the programs
  static constexpr const ProgramDescription progs[] = {
      {"sockops/add_to_sockhash", BPF_PROG_TYPE_SOCK_OPS, PROG_SOCKOPS_ADD_TO_SOCKHASH, NULL},
      {"sk_skb_verdict/redirect_socket", BPF_PROG_TYPE_SK_SKB, PROG_SK_SKB_VERDICT_REDIRECT_SOCKET, NULL},
  };

  // even if multiple filters are configured, just load the programs once
  static bool ebpf_loaded;

  static void attachSOCKOPS(struct bpf_object_skeleton* skel);
  static void attachSKSKB(struct bpf_object_skeleton* skel, int sockhash_fd);

  static void detachSOCKOPS(struct bpf_object_skeleton* skel);
  // XXX: no need for a detachSKSKB, the program detaches itself
};

/**
 * Throwed by the EbpfLoader methods
 */
class eBPFLoadException : public std::exception {
public:
  eBPFLoadException(std::string message_) : message(message_){};

  const char* what() const throw() { return message.c_str(); }

private:
  std::string message;
};

} // namespace EbpfTcpProxySKB
} // namespace EbpfTcpProxy
} // namespace TcpProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
