#include "ebpf_tcp_proxy_config.h"

#include <linux/if_link.h>
#include <linux/pkt_cls.h>

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace TcpProxy {
namespace EbpfTcpProxy {

bool EbpfLoader::ebpf_loaded = false;

/**
 * Load and attach the eBPF programs
 */
void EbpfLoader::loadeBPFPrograms(int interface_index,
                                  int* connection_fingerprint_to_connection_fingerprint_map_fd) {
  int err;

  if (ebpf_loaded) {
    return;
  }

  ebpf_loaded = true;

  struct bpf_object_skeleton* skel = NULL;

  // open eBPF application
  struct ebpf_tcp_proxy_bpf* obj = ebpf_tcp_proxy_bpf__open();
  if (!obj) {
    throw eBPFLoadException("Error while opening eBPF skeleton");
  }

  skel = obj->skeleton;

  // set program types
  for (int i = 0; i < skel->prog_cnt; i++) {
    bpf_program__set_type(*(skel->progs[i].prog), progs[i].type);
  }

  // load and verify eBPF programs
  if (ebpf_tcp_proxy_bpf__load(obj)) {
    throw eBPFLoadException("Error while loading eBPF program");
  }

  attachXDP(skel, interface_index);
  attachTC(skel, interface_index);

  // get the map file descriptor from the eBPF object
  *connection_fingerprint_to_connection_fingerprint_map_fd =
      bpf_map__fd(obj->maps.connection_fingerprint_to_connection_fingerprint_map);

  // put the interface index in a BPF_MAP_TYPE_ARRAY
  __u32 zero = 0;
  err = bpf_map_update_elem(bpf_map__fd(obj->maps.interface_index_map), &zero, &interface_index,
                            BPF_ANY);
  if (err < 0) {
    throw eBPFLoadException("Error while updating eBPF interface index map");
  }

  ENVOY_LOG_MISC(trace, "Successfully attached!");
}

/**
 * Attach the first XDP program to the interface; also set up the program map to allow tail calls
 */
void EbpfLoader::attachXDP(struct bpf_object_skeleton* skel, int interface_index) {
  int err;

  // attach the first XDP program to the interface
  err = bpf_xdp_attach(interface_index,
                       bpf_program__fd(*(skel->progs[PROG_XDP_REDIRECT_PACKET].prog)),
                       XDP_FLAGS_DRV_MODE, NULL);
  if (err) {
    throw eBPFLoadException("Error while attaching the XDP program to the interface");
  }
}

/**
 * Attach the "BLOCK FINS" TC program defined in the eBPF skeleton
 *
 * TODO: rewrite this using bpf_links, need to upgrade libbpf and bpftool
 */
void EbpfLoader::attachTC(struct bpf_object_skeleton* skel, int interface_index) {
  int err;

  int tc_fd = bpf_program__fd(*(skel->progs[PROG_CLS_BLOCK_FINS].prog));
  if (tc_fd < 0) {
    throw eBPFLoadException("Error while looking for the TC program");
  }

  // attach to the egress since it has to block FINs generated by Envoy
  LIBBPF_OPTS(bpf_tc_hook, hook, .ifindex = interface_index, .attach_point = BPF_TC_EGRESS);
  LIBBPF_OPTS(bpf_tc_opts, opts, .prog_fd = tc_fd);

  err = bpf_tc_hook_create(&hook);
  if (err == -EEXIST) {
    ENVOY_LOG_MISC(trace, "The TC hook already existed, continue");
  } else if (err) {
    throw eBPFLoadException("Failed to create TC hook");
  }

  err = bpf_tc_attach(&hook, &opts);
  if (err) {
    throw eBPFLoadException("Failed to attach TC program to interface");
  }
}

/**
 * Unload and detach the eBPF programs
 */
void EbpfLoader::unloadeBPFPrograms(int interface_index) {
  detachXDP(interface_index);
  detachTC(interface_index);
}

/**
 * Find all the XDP programs and detach them from the interface
 */
void EbpfLoader::detachXDP(int interface_index) {
  __u32 curr_prog_id = 0;

  if (!bpf_xdp_query_id(interface_index, XDP_FLAGS_DRV_MODE, &curr_prog_id)) {
    if (curr_prog_id) {
      bpf_xdp_detach(interface_index, XDP_FLAGS_DRV_MODE, NULL);
      ENVOY_LOG_MISC(trace, "Detached XDP program from interface");
      return;
    }
  }

  throw eBPFLoadException("Could not find a XDP program to detach");
}

/**
 * Detach the TC program and delete the qdisc
 *
 * XXX: this completely deletes the clsact qdisc, this assumes that there are no other TC programs on there
 */
void EbpfLoader::detachTC(int interface_index) {
    LIBBPF_OPTS(bpf_tc_hook, hook, .ifindex = interface_index, .attach_point = BPF_TC_EGRESS);
	int err = bpf_tc_hook_destroy(&hook);
	if (err < 0) {
  	 	throw eBPFLoadException("Failed to detach TC");
	}
}

/**
 * Construct a EbpfTcpProxy using a TcpProxy configuration
 */
Network::FilterFactoryCb EbpfTcpProxyConfigFactory::createFilterFactoryFromProtoTyped(
    const envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy& proto_config,
    Server::Configuration::FactoryContext& context) {
  ASSERT(!proto_config.stat_prefix().empty());

  Envoy::TcpProxy::ConfigSharedPtr filter_config(
      std::make_shared<Envoy::TcpProxy::Config>(proto_config, context));
  return [filter_config, &context, this](Network::FilterManager& filter_manager) -> void {
    filter_manager.addReadFilter(std::make_shared<Envoy::TcpProxy::EbpfTcpProxy::EbpfTcpProxy>(
        filter_config, context.serverFactoryContext().clusterManager(),
        connection_fingerprint_to_connection_fingerprint_map_fd));
  };
}

/**
 * Load the eBPF programs, extract the TcpProxy configuration from the EbpfTcpProxy
 * one, then instantiate the filter
 */
Network::FilterFactoryCb EbpfTcpProxyConfigFactory::createFilterFactoryFromProtoTyped(
    const envoy::extensions::filters::network::tcp_proxy::v3::EbpfTcpProxy& proto_config,
    Server::Configuration::FactoryContext& context) {
  interface_index = proto_config.interface_index();

  // load the eBPF program and get the map descriptor
  try {
    EbpfLoader::loadeBPFPrograms(interface_index,
                                 &connection_fingerprint_to_connection_fingerprint_map_fd);
  } catch (eBPFLoadException& e) {
    ENVOY_LOG_MISC(error, e.what());
    throw std::runtime_error(e.what());
  }

  // construct the EbpfTcpProxy filter using a TcpProxy configuration
  return EbpfTcpProxyConfigFactory::createFilterFactoryFromProtoTyped(proto_config.tcp_proxy(),
                                                                      context);
}

} // namespace EbpfTcpProxy
} // namespace TcpProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
