#include "ebpf_loader_xdp.h"

#include <linux/if_link.h>
#include <linux/pkt_cls.h>

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace TcpProxy {
namespace EbpfTcpProxy {
namespace EbpfTcpProxyXDP {

bool EbpfLoader::ebpf_loaded = false;

/**
 * Load and attach the XDP eBPF programs
 */
void EbpfLoader::loadeBPFPrograms(int interface_index, int* connection_fingerprint_to_connection_fingerprint_map_fd) {
  int err;

  if (ebpf_loaded) {
    return;
  }

  ebpf_loaded = true;

  struct bpf_object_skeleton* skel = NULL;

  // open eBPF application
  struct ebpf_tcp_proxy_xdp_bpf* obj = ebpf_tcp_proxy_xdp_bpf__open();
  if (!obj) {
    throw eBPFLoadException("Error while opening eBPF skeleton");
  }

  skel = obj->skeleton;

  // set program types
  for (int i = 0; i < skel->prog_cnt; i++) {
    bpf_program__set_type(*(skel->progs[i].prog), progs[i].type);
  }

  // load and verify eBPF programs
  if (ebpf_tcp_proxy_xdp_bpf__load(obj)) {
    throw eBPFLoadException("Error while loading eBPF program");
  }

  // get the map file descriptor from the eBPF object
  *connection_fingerprint_to_connection_fingerprint_map_fd =
      bpf_map__fd(obj->maps.connection_fingerprint_to_connection_fingerprint_map);

  attachXDP(skel, interface_index);
  attachTC(skel, interface_index);

  // put the interface index in a BPF_MAP_TYPE_ARRAY
  __u32 zero = 0;
  err = bpf_map_update_elem(bpf_map__fd(obj->maps.interface_index_map), &zero, &interface_index,
                            BPF_ANY);
  if (err < 0) {
    throw eBPFLoadException("Error while updating eBPF interface index map");
  }

  ENVOY_LOG_MISC(trace, "Successfully attached!");
}

/**
 * Attach the "REDIRECT PACKET" XDP program to the interface
 */
void EbpfLoader::attachXDP(struct bpf_object_skeleton* skel, int interface_index) {
  int err;

  // attach the first XDP program to the interface
  err = bpf_xdp_attach(interface_index,
                       bpf_program__fd(*(skel->progs[PROG_XDP_REDIRECT_PACKET].prog)),
                       XDP_FLAGS_DRV_MODE, NULL);
  if (err) {
    throw eBPFLoadException("Failed to attach the XDP program to the interface");
  }
}

/**
 * Attach the "BLOCK FINS" TC program to the interface
 *
 * TODO: rewrite this using bpf_links, need to upgrade libbpf and bpftool
 */
void EbpfLoader::attachTC(struct bpf_object_skeleton* skel, int interface_index) {
  int err;

  int tc_fd = bpf_program__fd(*(skel->progs[PROG_CLS_BLOCK_FINS].prog));
  if (tc_fd < 0) {
    throw eBPFLoadException("Error while looking for the TC program");
  }

  // attach to the egress since it has to block FINs generated by Envoy
  LIBBPF_OPTS(bpf_tc_hook, hook, .ifindex = interface_index, .attach_point = BPF_TC_EGRESS);
  LIBBPF_OPTS(bpf_tc_opts, opts, .prog_fd = tc_fd);

  err = bpf_tc_hook_create(&hook);
  if (err == -EEXIST) {
    ENVOY_LOG_MISC(trace, "The TC hook already existed, continue");
  } else if (err) {
    throw eBPFLoadException("Failed to create TC hook");
  }

  err = bpf_tc_attach(&hook, &opts);
  if (err) {
    throw eBPFLoadException("Failed to attach TC program to interface");
  }
}

/**
 * Unload and detach the eBPF programs
 */
void EbpfLoader::unloadeBPFPrograms(int interface_index) {
  if (!ebpf_loaded) {
    return;
  }

  detachXDP(interface_index);
  detachTC(interface_index);
}

/**
 * Find all the XDP programs and detach them from the interface
 */
void EbpfLoader::detachXDP(int interface_index) {
  __u32 curr_prog_id = 0;

  if (!bpf_xdp_query_id(interface_index, XDP_FLAGS_DRV_MODE, &curr_prog_id)) {
    if (curr_prog_id) {
      bpf_xdp_detach(interface_index, XDP_FLAGS_DRV_MODE, NULL);
      ENVOY_LOG_MISC(trace, "Detached XDP program from interface");
      return;
    }
  }

  throw eBPFLoadException("Could not find a XDP program to detach");
}

/**
 * Detach the TC program and delete the qdisc
 *
 * XXX: this completely deletes the clsact qdisc, this assumes that there are no other TC programs
 * on there
 */
void EbpfLoader::detachTC(int interface_index) {
  LIBBPF_OPTS(bpf_tc_hook, hook, .ifindex = interface_index, .attach_point = BPF_TC_EGRESS);
  int err = bpf_tc_hook_destroy(&hook);
  if (err < 0) {
    throw eBPFLoadException("Failed to detach TC program");
  }
}

} // namespace EbpfTcpProxyXDP
} // namespace EbpfTcpProxy
} // namespace TcpProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
